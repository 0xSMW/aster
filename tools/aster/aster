#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"

usage() {
  cat >&2 <<'TXT'
usage: tools/aster/aster <cmd> [args...]

cmd:
  build <path.as|project_dir> [out]
  run   <path.as|project_dir> [-- args...]
  test
  bench [bench_args...]

env:
  ASTER_COMPILER      path to tools/build/out/asterc (default: repo)
  ASTER_CACHE=1       enable content-hash build cache for `build`/`run`
  ASTER_CACHE_DIR     cache root (default: .context/aster/cache)
TXT
}

find_root() {
  # Walk upward looking for aster.toml; fall back to current dir.
  local start="${1:-$PWD}"
  local d="$start"
  while true; do
    if [[ -f "$d/aster.toml" ]]; then
      printf '%s\n' "$d"
      return 0
    fi
    if [[ "$d" == "/" ]]; then
      printf '%s\n' "$PWD"
      return 0
    fi
    d="$(cd "$d/.." && pwd)"
  done
}

resolve_entry() {
  local path="$1"
  if [[ -d "$path" ]]; then
    if [[ -f "$path/src/main.as" ]]; then
      printf '%s\n' "$path/src/main.as"
      return 0
    fi
    echo "aster: missing src/main.as in project dir: $path" >&2
    exit 2
  fi
  printf '%s\n' "$path"
}

mod_path_to_file() {
  local root="$1"
  local mod="$2"
  # `use foo.bar` -> <root>/src/foo/bar.as
  local rel="${mod//./\/}.as"
  printf '%s\n' "$root/src/$rel"
}

preprocess_modules() {
  local root="$1"
  local entry="$2"
  local out_as="$3"

  # Very small "module system" for now:
  # - Supports `use foo.bar` lines at top-level.
  # - Expands by concatenating sources in dependency order.
  # - Removes `use ...` lines from the concatenated output so Aster1 compiler doesn't need `use`.
  local root_abs
  root_abs="$(cd "$root" && pwd)"

  local visited="|"
  local order_list=()

  # Extract leading `use foo.bar` directives from a file.
  parse_uses() {
    local file="$1"
    local in_preamble=1
    while IFS= read -r line || [[ -n "$line" ]]; do
      # left-trim
      local t="${line#"${line%%[!$' \t']*}"}"
      if [[ "$in_preamble" -eq 1 ]]; then
        if [[ -z "$t" || "${t:0:1}" == "#" ]]; then
          continue
        fi
        if [[ "$t" =~ ^use[[:space:]]+([A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*)[[:space:]]*$ ]]; then
          printf '%s\n' "${BASH_REMATCH[1]}"
          continue
        fi
        break
      fi
    done < "$file"
  }

  # Print a file with its leading `use` directives removed.
  strip_use_block() {
    local file="$1"
    local in_preamble=1
    while IFS= read -r line || [[ -n "$line" ]]; do
      local t="${line#"${line%%[!$' \t']*}"}"
      if [[ "$in_preamble" -eq 1 ]]; then
        if [[ "$t" =~ ^use[[:space:]]+([A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*)[[:space:]]*$ ]]; then
          continue
        fi
        if [[ -z "$t" || "${t:0:1}" == "#" ]]; then
          echo "$line"
          continue
        fi
        in_preamble=0
      fi
      echo "$line"
    done < "$file"
  }

  is_visited() {
    local key="|$1|"
    case "$visited" in
      *"$key"*) return 0 ;;
      *) return 1 ;;
    esac
  }

  mark_visited() {
    visited="${visited}$1|"
  }

  abs_path() {
    local f="$1"
    local d
    d="$(cd "$(dirname "$f")" && pwd)"
    printf '%s/%s\n' "$d" "$(basename "$f")"
  }

  dfs_file() {
    local file="$1"
    local abs
    abs="$(abs_path "$file")"
    if is_visited "$abs"; then
      return 0
    fi
    mark_visited "$abs"
    while IFS= read -r mod; do
      [[ -n "$mod" ]] || continue
      local dep
      dep="$(mod_path_to_file "$root_abs" "$mod")"
      if [[ ! -f "$dep" ]]; then
        echo "aster: module not found: use $mod -> $dep" >&2
        exit 2
      fi
      dfs_file "$dep"
    done < <(parse_uses "$abs")
    order_list+=("$abs")
  }

  dfs_file "$entry"

  mkdir -p "$(dirname "$out_as")"
  : > "$out_as"
  for file in "${order_list[@]}"; do
    local rel="$file"
    case "$file" in
      "$root_abs"/*) rel="${file#$root_abs/}" ;;
    esac
    printf '# --- module: %s ---\n' "$rel" >>"$out_as"
    strip_use_block "$file" >>"$out_as"
    printf '\n\n' >>"$out_as"
  done
}

do_build() {
  local path="$1"
  local out="${2:-}"

  local entry
  entry="$(resolve_entry "$path")"
  if [[ ! -f "$entry" ]]; then
    echo "aster: entry not found: $entry" >&2
    exit 2
  fi

  local root_dir
  root_dir="$(find_root "$(cd "$(dirname "$entry")" && pwd)")"

  local out_bin
  if [[ -n "$out" ]]; then
    out_bin="$out"
  else
    base="$(basename "$entry" .as)"
    out_bin="$ROOT/.context/aster/build/out/$base"
  fi

  local cache_root="${ASTER_CACHE_DIR:-$ROOT/.context/aster/cache}"
  mkdir -p "$cache_root"

  local asterc="${ASTER_COMPILER:-$ROOT/tools/build/out/asterc}"
  if [[ ! -x "$asterc" ]]; then
    bash "$ROOT/tools/build/build.sh" "$ROOT/asm/driver/asterc.S" >/dev/null
  fi

  # Preprocess modules into a combined source.
  local tmp_root="$ROOT/.context/aster/build/tmp"
  mkdir -p "$tmp_root"
  local combined="$tmp_root/combined.as"
  preprocess_modules "$root_dir" "$entry" "$combined"

  if [[ -n "${ASTER_CACHE:-}" && "${ASTER_CACHE}" != "0" ]]; then
    src_sha="$(shasum -a 256 "$combined" | awk '{print $1}')"
    cc_sha="$(shasum -a 256 "$asterc" | awk '{print $1}')"
    key="${src_sha}_${cc_sha}"
    ent="$cache_root/$key"
    if [[ -x "$ent/out" ]]; then
      mkdir -p "$(dirname "$out_bin")"
      cp -f "$ent/out" "$out_bin"
      if [[ -f "$ent/out.ll" ]]; then
        cp -f "$ent/out.ll" "${out_bin}.ll"
      fi
      echo "built (cache) $out_bin"
      return 0
    fi
    mkdir -p "$ent"
    "$ROOT/tools/build/asterc.sh" "$combined" "$ent/out"
    mkdir -p "$(dirname "$out_bin")"
    cp -f "$ent/out" "$out_bin"
    if [[ -f "$ent/out.ll" ]]; then
      cp -f "$ent/out.ll" "${out_bin}.ll"
    fi
    echo "built $out_bin"
    return 0
  fi

  mkdir -p "$(dirname "$out_bin")"
  "$ROOT/tools/build/asterc.sh" "$combined" "$out_bin"
  echo "built $out_bin"
}

do_run() {
  local path="$1"
  shift
  local out="$ROOT/.context/aster/run/bin"
  do_build "$path" "$out"
  exec "$out" "$@"
}

cmd="${1:-}"
if [[ -z "$cmd" ]]; then
  usage
  exit 2
fi
shift || true

case "$cmd" in
  build)
    if [[ $# -lt 1 || $# -gt 2 ]]; then usage; exit 2; fi
    do_build "$@"
    ;;
  run)
    if [[ $# -lt 1 ]]; then usage; exit 2; fi
    path="$1"; shift
    if [[ "${1:-}" == "--" ]]; then shift; fi
    do_run "$path" "$@"
    ;;
  test)
    bash "$ROOT/aster/tests/run.sh"
    ;;
  bench)
    # Convenience flags (translate to env vars consumed by tools/bench/run.sh).
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --kernels)
          export BENCH_SET=kernels
          shift
          ;;
        --fswalk)
          export BENCH_SET=fswalk
          shift
          ;;
        --all)
          export BENCH_SET=all
          shift
          ;;
        --fs-root)
          export FS_BENCH_ROOT="${2:?missing arg to --fs-root}"
          shift 2
          ;;
        --max-depth)
          export FS_BENCH_MAX_DEPTH="${2:?missing arg to --max-depth}"
          shift 2
          ;;
        --list-fixed)
          export FS_BENCH_LIST_FIXED=1
          export FS_BENCH_TREEWALK_LIST_FIXED=1
          export FS_BENCH_STRICT=1
          shift
          ;;
        --treewalk-mode)
          export FS_BENCH_TREEWALK_MODE="${2:?missing arg to --treewalk-mode}"
          shift 2
          ;;
        --cpp-mode)
          export FS_BENCH_CPP_MODE="${2:?missing arg to --cpp-mode}"
          shift 2
          ;;
        --build-timing)
          export BENCH_BUILD_TIMING=1
          shift
          ;;
        --)
          shift
          break
          ;;
        *)
          break
          ;;
      esac
    done
    bash "$ROOT/tools/bench/run.sh"
    ;;
  -h|--help|help)
    usage
    ;;
  *)
    echo "aster: unknown cmd: $cmd" >&2
    usage
    exit 2
    ;;
esac
